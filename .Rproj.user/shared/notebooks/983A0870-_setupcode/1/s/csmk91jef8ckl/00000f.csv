"0","#| include: false"
"0",""
"0","# ---- Support Functions"
"0",""
"0","# function: mykable"
"0","# description: Create a default version of kbl()."
"0","mykable <- function(x, ...) {"
"0","  kableExtra::kbl(x, booktabs = TRUE, ...) |>"
"0","    kableExtra::kable_styling("
"0","      bootstrap_options = c('striped', 'responsive'),"
"0","      latex_options = c('striped'),"
"0","      position = 'center'"
"0","    )"
"0","}"
"0",""
"0",""
"0","# function: get_block"
"0","# description: Extract fenced blocks from a QMD document matching some pattern."
"0","repeat_block <- function(x, pattern) {"
"0","  # find start lines"
"0","  startind <- x |>"
"0","    str_detect(pattern = pattern) |>"
"0","    which()"
"0","  "
"0","  # find all fenced blocks"
"0","  allind <- x |>"
"0","    str_detect(fixed(':::')) |>"
"0","    which()"
"0","  "
"0","  # find end of each block"
"0","  endind <- allind[(is.element(allind, startind) |> which()) + 1]"
"0","  "
"0","  map2(startind, endind, ~ x[.x:.y])"
"0","}"
"0",""
"0",""
"0","# function: trim_vector"
"0","# description: Remove empty elements from beginning and end of a vector."
"0","trim_vector <- function(x, side = c('both', 'left', 'right')) {"
"0","  if ((side == 'left') || (side == 'both')) {"
"0","    x <- x[c((which(str_detect(x, '[[:graph:]]'))[1]):(length(x)))]"
"0","  }"
"0","  "
"0","  if ((side == 'right') || (side == 'both')) {"
"0","    x <- x[c(1L:(rev(which(str_detect(x, '[[:graph:]]')))[1]))]"
"0","  }"
"0","  "
"0","  return(x)"
"0","}"
"0",""
"0",""
"0",""
"0","# function: get_terms"
"0","# description: Given a list of fenced blocks, extract terms."
"0","get_terms <- function(x, term = c('reference', 'title', 'text', 'fullblock')) {"
"0","  if (term == 'reference') {"
"0","    map_chr(x, ~ .x |>"
"0","              str_subset(pattern = ':::\\{#') |>"
"0","              str_remove_all(pattern = '(:::\\{#)|(\\})'))"
"0","  } else if (term == 'title') {"
"0","    map_chr(x, ~ .x |> "
"0","              str_subset(pattern = '##') |> "
"0","              str_remove(pattern = '##') |>"
"0","              str_trim())"
"0","  } else if (term == 'text') {"
"0","    map_chr(x, ~ .x |>"
"0","            str_subset(pattern = '(:::)|(##)', negate = TRUE) |>"
"0","            trim_vector(side = 'both') |>"
"0","            str_c(collapse = '\n'))"
"0","    "
"0","    "
"0","  } else if (term == 'fullblock') {"
"0","    map_chr(x, ~ .x |>"
"0","              str_subset(pattern = ':::', negate = TRUE) |>"
"0","              str_c(collapse = '\n'))"
"0","  }"
"0","}"
"0",""
"0",""
"0","# ---- fct-if_exceeds_threshold ----"
"0","# Description: If x > a, return x. Otherwise, return a."
"0","#"
"0","# Parameters:"
"0","#   x          Numeric. Value of interest."
"0","#   a          Numeric. Threshhold (default = 0)."
"0","if_exceeds_threshold <- function(x, a = 0){"
"0","  ifelse(x >= a, x, a)"
"0","}"
"0",""
"0",""
"0",""
"0",""
"0","# ---- fct-display_est ----"
"0","# Description: Given model output, display the estimate for a particular"
"0","#              variable in text, rounding appropriately."
"0","#"
"0","# Parameters:"
"0","#   value      Numeric. Value to be printed."
"0","#   digits     Scalar. The number of digits to format the value to. This is"
"0","#                used to determine the precision with which the value is "
"0","#                formatted. (default = 2)"
"0","#"
"0","# Details:"
"0","#   The values in value are first rounded to the appropriate number of"
"0","#   digits. If that results in 0, then the values are placed in scientific "
"0","#   notation with digits representing the number of significant figures. So,"
"0","#   with digits = 2, 0.00123 becomes 1.2e-03, 0.0091 becomes 0.01, and 0.012"
"0","#   becomes 0.01."
"0","#"
"0","#   If a value is at least 10, we decrease the number of decimal places by each"
"0","#   power of 10 the value increases.  So, with digits = 2, 1.234 becomes 1.23,"
"0","#   12.34 becomes 12.3 and 123.456 becomes 123."
"0","display_est <- function(value, digits = 2){"
"0","  roundingDigits <- "
"0","    if_exceeds_threshold("
"0","      digits - if_exceeds_threshold(floor(log10(abs(value)))))"
"0","  "
"0","  ifelse(round(value, digits) == 0L,"
"0","         format(value, digits = digits, scientific = TRUE),"
"0","         round(value, roundingDigits) %>% as.character())"
"0","}"
"0",""
"0",""
"0",""
"0","# ---- fct-display_CI ----"
"0","# Description: Given lower and upper bounds, format a confidence interval for"
"0","#              display in text or tables."
"0","#"
"0","# Parameters:"
"0","#   lower      Numeric. Lower bound of CI."
"0","#   upper      Numeric. Upper bound of CI."
"0","#   digits     Scalar. The number of digits to format the value to. This is"
"0","#                used to determine the precision with which the value is "
"0","#                formatted. (default = 2)"
"0","#   trans      A function which applies a transformation to the estimate"
"0","#                (default = no transformation)."
"0","#"
"0","# Details:"
"0","#   The values in lower and upper are first rounded to the appropriate number of"
"0","#   digits. If that results in 0, then the values are placed in scientific "
"0","#   notation with digits representing the number of significant figures. So,"
"0","#   with digits = 2, 0.00123 becomes 1.2e-03, 0.0091 becomes 0.01, and 0.012"
"0","#   becomes 0.01."
"0","#"
"0","#   If a value is at least 10, we decrease the number of decimal places by each"
"0","#   power of 10 the value increases.  So, with digits = 2, 1.234 becomes 1.23,"
"0","#   12.34 becomes 12.3 and 123.456 becomes 123."
"0","display_CI <- function(lower, upper, digits = 2,"
"0","                       trans = function(u) u){"
"0","  if (digits < 0){"
"0","    rlang::abort(""digits must be nonnegative."")"
"0","  }"
"0","  "
"0","  if (trans(lower) > trans(upper)){"
"0","    tu <- upper"
"0","    tl <- lower"
"0","    "
"0","    lower <- trans(tu)"
"0","    upper <- trans(tl)"
"0","  } else {"
"0","    lower <- trans(lower)"
"0","    upper <- trans(upper)"
"0","  }"
"0","  "
"0","  lowerRoundingDigits <- "
"0","    if_exceeds_threshold("
"0","      digits - if_exceeds_threshold(floor(log10(abs(lower)))))"
"0","  "
"0","  upperRoundingDigits <-"
"0","    if_exceeds_threshold("
"0","      digits - if_exceeds_threshold(floor(log10(abs(upper)))))"
"0","  "
"0","  "
"0","  lower <- ifelse(round(lower, digits) == 0L,"
"0","                  format(lower, digits = digits, scientific = TRUE),"
"0","                  round(lower, lowerRoundingDigits) %>% as.character())"
"0","  "
"0","  upper <- ifelse(round(upper, digits) == 0L,"
"0","                  format(upper, digits = digits, scientific = TRUE),"
"0","                  round(upper, upperRoundingDigits) %>% as.character())"
"0","  "
"0","  "
"0","  # print"
"0","  paste0(""["", lower, "", "", upper, ""]"")"
"0","}"
"0",""
"0",""
"0",""
"0",""
"0","# ---- fct-model_display_CI ----"
"0","# Description: Given model output, display the p-value for a particular"
"0","#              variable in text using the display_CI function."
"0","#"
"0","# Parameters:"
"0","#   model      The model output used to obtain the p-value (should be the"
"0","#                output of a broom::tidy() call)."
"0","#   term       The string representation of the term to use."
"0","#   digits     See display_CI()"
"0","#   trans      A function which applies a transformation to the estimate"
"0","#                (default = no transformation)."
"0","model_display_CI <- function(model, selectedTerm, digits = 2, "
"0","                             trans = function(u) u){"
"0","  model %>% "
"0","    filter(term == selectedTerm) %>% "
"0","    mutate(CI = map2_chr(conf.low, conf.high, display_CI, digits = digits,"
"0","                         trans = trans)) %>%"
"0","    pull(CI)"
"0","}"
"0",""
"0",""
"0",""
"0",""
"0","# ---- fct-model_display_est ----"
"0","# Description: Given model output, display the estimate for a particular"
"0","#              variable in text, rounding appropriately."
"0","#"
"0","# Parameters:"
"0","#   model      The model output used to obtain the p-value (should be the"
"0","#                output of a broom::tidy() call)."
"0","#   term       The string representation of the term to use."
"0","#   digits     See display_CI()"
"0","#   trans      A function which applies a transformation to the estimate"
"0","#                (default = no transformation)."
"0","model_display_est <- function(model, selectedTerm, digits = 2,"
"0","                              trans = function(u) u){"
"0","  estimate <- model %>%"
"0","    filter(term == selectedTerm) %>%"
"0","    pull(estimate) %>%"
"0","    trans()"
"0","  "
"0","  display_est(estimate)"
"0","}"
"0",""
"0",""
"0","# ---- fct-my_scale ----"
"0","# Description: Given a numeric vector of values, rescales the variables to "
"0","#              exist on the interval (low, high)."
"0","my_scale <- function(u, low = 0, high = 1){"
"0","  minmax <- range(u)"
"0","  u <- (u - minmax[1]) / diff(minmax)"
"0","  "
"0","  (u * (high - low)) + low"
"0","}"
